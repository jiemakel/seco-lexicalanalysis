// Generated by http://code.google.com/p/protostuff/ ... DO NOT EDIT!
// Generated from connexor.proto

package fi.seco.lexical.connexor.model;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.ArrayList;
import java.util.List;

import com.dyuproject.protostuff.GraphIOUtil;
import com.dyuproject.protostuff.Input;
import com.dyuproject.protostuff.Message;
import com.dyuproject.protostuff.Output;
import com.dyuproject.protostuff.Schema;

public final class MPTResponse implements Externalizable, Message<MPTResponse> {
	public static final class Token implements Externalizable, Message<Token> {
		public static final class Reading implements Externalizable, Message<Reading> {

			public static Schema<Reading> getSchema() {
				return SCHEMA;
			}

			public static Reading getDefaultInstance() {
				return DEFAULT_INSTANCE;
			}

			static final Reading DEFAULT_INSTANCE = new Reading();

			// non-private fields
			// see http://developer.android.com/guide/practices/design/performance.html#package_inner
			String baseform;
			String morpho;
			String sub1;
			String sub2;
			String custom;
			String syntax;

			public Reading() {

			}

			// getters and setters

			// baseform

			public String getBaseform() {
				return baseform;
			}

			public void setBaseform(String baseform) {
				this.baseform = baseform;
			}

			// morpho

			public String getMorpho() {
				return morpho;
			}

			public void setMorpho(String morpho) {
				this.morpho = morpho;
			}

			// sub1

			public String getSub1() {
				return sub1;
			}

			public void setSub1(String sub1) {
				this.sub1 = sub1;
			}

			// sub2

			public String getSub2() {
				return sub2;
			}

			public void setSub2(String sub2) {
				this.sub2 = sub2;
			}

			// custom

			public String getCustom() {
				return custom;
			}

			public void setCustom(String custom) {
				this.custom = custom;
			}

			// syntax

			public String getSyntax() {
				return syntax;
			}

			public void setSyntax(String syntax) {
				this.syntax = syntax;
			}

			// java serialization

			@Override
			public void readExternal(ObjectInput in) throws IOException {
				GraphIOUtil.mergeDelimitedFrom(in, this, SCHEMA);
			}

			@Override
			public void writeExternal(ObjectOutput out) throws IOException {
				GraphIOUtil.writeDelimitedTo(out, this, SCHEMA);
			}

			// message method

			@Override
			public Schema<Reading> cachedSchema() {
				return SCHEMA;
			}

			static final Schema<Reading> SCHEMA = new Schema<Reading>() {
				// schema methods

				@Override
				public Reading newMessage() {
					return new Reading();
				}

				@Override
				public Class<Reading> typeClass() {
					return Reading.class;
				}

				@Override
				public String messageName() {
					return Reading.class.getSimpleName();
				}

				@Override
				public String messageFullName() {
					return Reading.class.getName();
				}

				@Override
				public boolean isInitialized(Reading message) {
					return true;
				}

				@Override
				public void mergeFrom(Input input, Reading message) throws IOException {
					for (int number = input.readFieldNumber(this);; number = input.readFieldNumber(this))
						switch (number) {
						case 0:
							return;
						case 1:
							message.baseform = input.readString();
							break;
						case 2:
							message.morpho = input.readString();
							break;
						case 3:
							message.sub1 = input.readString();
							break;
						case 4:
							message.sub2 = input.readString();
							break;
						case 5:
							message.custom = input.readString();
							break;
						case 6:
							message.syntax = input.readString();
							break;
						default:
							input.handleUnknownField(number, this);
						}
				}

				@Override
				public void writeTo(Output output, Reading message) throws IOException {
					if (message.baseform != null) output.writeString(1, message.baseform, false);

					if (message.morpho != null) output.writeString(2, message.morpho, false);

					if (message.sub1 != null) output.writeString(3, message.sub1, false);

					if (message.sub2 != null) output.writeString(4, message.sub2, false);

					if (message.custom != null) output.writeString(5, message.custom, false);

					if (message.syntax != null) output.writeString(6, message.syntax, false);
				}

				@Override
				public String getFieldName(int number) {
					switch (number) {
					case 1:
						return "baseform";
					case 2:
						return "morpho";
					case 3:
						return "sub1";
					case 4:
						return "sub2";
					case 5:
						return "custom";
					case 6:
						return "syntax";
					default:
						return null;
					}
				}

				@Override
				public int getFieldNumber(String name) {
					final Integer number = fieldMap.get(name);
					return number == null ? 0 : number.intValue();
				}

				final java.util.HashMap<String, Integer> fieldMap = new java.util.HashMap<String, Integer>();
				{
					fieldMap.put("baseform", 1);
					fieldMap.put("morpho", 2);
					fieldMap.put("sub1", 3);
					fieldMap.put("sub2", 4);
					fieldMap.put("custom", 5);
					fieldMap.put("syntax", 6);
				}
			};

		}

		public static Schema<Token> getSchema() {
			return SCHEMA;
		}

		public static Token getDefaultInstance() {
			return DEFAULT_INSTANCE;
		}

		static final Token DEFAULT_INSTANCE = new Token();

		// non-private fields
		// see http://developer.android.com/guide/practices/design/performance.html#package_inner
		String textform;
		Integer position;
		Integer length;
		String sentenceBoundary;
		String nounPhraseInfo;
		List<Reading> reading;

		public Token() {

		}

		// getters and setters

		// textform

		public String getTextform() {
			return textform;
		}

		public void setTextform(String textform) {
			this.textform = textform;
		}

		// position

		public Integer getPosition() {
			return position;
		}

		public void setPosition(Integer position) {
			this.position = position;
		}

		// length

		public Integer getLength() {
			return length;
		}

		public void setLength(Integer length) {
			this.length = length;
		}

		// sentenceBoundary

		public String getSentenceBoundary() {
			return sentenceBoundary;
		}

		public void setSentenceBoundary(String sentenceBoundary) {
			this.sentenceBoundary = sentenceBoundary;
		}

		// nounPhraseInfo

		public String getNounPhraseInfo() {
			return nounPhraseInfo;
		}

		public void setNounPhraseInfo(String nounPhraseInfo) {
			this.nounPhraseInfo = nounPhraseInfo;
		}

		// reading

		public List<Reading> getReadingList() {
			return reading;
		}

		public void setReadingList(List<Reading> reading) {
			this.reading = reading;
		}

		// java serialization

		@Override
		public void readExternal(ObjectInput in) throws IOException {
			GraphIOUtil.mergeDelimitedFrom(in, this, SCHEMA);
		}

		@Override
		public void writeExternal(ObjectOutput out) throws IOException {
			GraphIOUtil.writeDelimitedTo(out, this, SCHEMA);
		}

		// message method

		@Override
		public Schema<Token> cachedSchema() {
			return SCHEMA;
		}

		static final Schema<Token> SCHEMA = new Schema<Token>() {
			// schema methods

			@Override
			public Token newMessage() {
				return new Token();
			}

			@Override
			public Class<Token> typeClass() {
				return Token.class;
			}

			@Override
			public String messageName() {
				return Token.class.getSimpleName();
			}

			@Override
			public String messageFullName() {
				return Token.class.getName();
			}

			@Override
			public boolean isInitialized(Token message) {
				return true;
			}

			@Override
			public void mergeFrom(Input input, Token message) throws IOException {
				for (int number = input.readFieldNumber(this);; number = input.readFieldNumber(this))
					switch (number) {
					case 0:
						return;
					case 1:
						message.textform = input.readString();
						break;
					case 2:
						message.position = input.readInt32();
						break;
					case 3:
						message.length = input.readInt32();
						break;
					case 4:
						message.sentenceBoundary = input.readString();
						break;
					case 5:
						message.nounPhraseInfo = input.readString();
						break;
					case 6:
						if (message.reading == null) message.reading = new ArrayList<Reading>();
						message.reading.add(input.mergeObject(null, Reading.getSchema()));
						break;

					default:
						input.handleUnknownField(number, this);
					}
			}

			@Override
			public void writeTo(Output output, Token message) throws IOException {
				if (message.textform != null) output.writeString(1, message.textform, false);

				if (message.position != null) output.writeInt32(2, message.position, false);

				if (message.length != null) output.writeInt32(3, message.length, false);

				if (message.sentenceBoundary != null) output.writeString(4, message.sentenceBoundary, false);

				if (message.nounPhraseInfo != null) output.writeString(5, message.nounPhraseInfo, false);

				if (message.reading != null) for (Reading reading : message.reading)
					if (reading != null) output.writeObject(6, reading, Reading.getSchema(), true);

			}

			@Override
			public String getFieldName(int number) {
				switch (number) {
				case 1:
					return "textform";
				case 2:
					return "position";
				case 3:
					return "length";
				case 4:
					return "sentenceBoundary";
				case 5:
					return "nounPhraseInfo";
				case 6:
					return "reading";
				default:
					return null;
				}
			}

			@Override
			public int getFieldNumber(String name) {
				final Integer number = fieldMap.get(name);
				return number == null ? 0 : number.intValue();
			}

			final java.util.HashMap<String, Integer> fieldMap = new java.util.HashMap<String, Integer>();
			{
				fieldMap.put("textform", 1);
				fieldMap.put("position", 2);
				fieldMap.put("length", 3);
				fieldMap.put("sentenceBoundary", 4);
				fieldMap.put("nounPhraseInfo", 5);
				fieldMap.put("reading", 6);
			}
		};

	}

	public static Schema<MPTResponse> getSchema() {
		return SCHEMA;
	}

	public static MPTResponse getDefaultInstance() {
		return DEFAULT_INSTANCE;
	}

	static final MPTResponse DEFAULT_INSTANCE = new MPTResponse();

	// non-private fields
	// see http://developer.android.com/guide/practices/design/performance.html#package_inner
	List<Token> token;
	String error;

	public MPTResponse() {

	}

	// getters and setters

	// token

	public List<Token> getTokenList() {
		return token;
	}

	public void setTokenList(List<Token> token) {
		this.token = token;
	}

	// error

	public String getError() {
		return error;
	}

	public void setError(String error) {
		this.error = error;
	}

	// java serialization

	@Override
	public void readExternal(ObjectInput in) throws IOException {
		GraphIOUtil.mergeDelimitedFrom(in, this, SCHEMA);
	}

	@Override
	public void writeExternal(ObjectOutput out) throws IOException {
		GraphIOUtil.writeDelimitedTo(out, this, SCHEMA);
	}

	// message method

	@Override
	public Schema<MPTResponse> cachedSchema() {
		return SCHEMA;
	}

	static final Schema<MPTResponse> SCHEMA = new Schema<MPTResponse>() {
		// schema methods

		@Override
		public MPTResponse newMessage() {
			return new MPTResponse();
		}

		@Override
		public Class<MPTResponse> typeClass() {
			return MPTResponse.class;
		}

		@Override
		public String messageName() {
			return MPTResponse.class.getSimpleName();
		}

		@Override
		public String messageFullName() {
			return MPTResponse.class.getName();
		}

		@Override
		public boolean isInitialized(MPTResponse message) {
			return true;
		}

		@Override
		public void mergeFrom(Input input, MPTResponse message) throws IOException {
			for (int number = input.readFieldNumber(this);; number = input.readFieldNumber(this))
				switch (number) {
				case 0:
					return;
				case 2:
					if (message.token == null) message.token = new ArrayList<Token>();
					message.token.add(input.mergeObject(null, Token.getSchema()));
					break;

				case 255:
					message.error = input.readString();
					break;
				default:
					input.handleUnknownField(number, this);
				}
		}

		@Override
		public void writeTo(Output output, MPTResponse message) throws IOException {
			if (message.token != null) for (Token token : message.token)
				if (token != null) output.writeObject(2, token, Token.getSchema(), true);

			if (message.error != null) output.writeString(255, message.error, false);
		}

		@Override
		public String getFieldName(int number) {
			switch (number) {
			case 2:
				return "token";
			case 255:
				return "error";
			default:
				return null;
			}
		}

		@Override
		public int getFieldNumber(String name) {
			final Integer number = fieldMap.get(name);
			return number == null ? 0 : number.intValue();
		}

		final java.util.HashMap<String, Integer> fieldMap = new java.util.HashMap<String, Integer>();
		{
			fieldMap.put("token", 2);
			fieldMap.put("error", 255);
		}
	};

}
